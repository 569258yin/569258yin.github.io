{"meta":{"title":"Hao Yin Blog","subtitle":"记录生活，分享感动","description":"它是一种分享，同时是一种记忆","author":"Hao Yin","url":"http://569258yin.github.io"},"pages":[],"posts":[{"title":"javaweb与app实现文件上传","slug":"javaweb与app实现文件上传","date":"2017-03-13T12:54:27.000Z","updated":"2017-03-14T01:06:10.871Z","comments":true,"path":"2017/03/13/javaweb与app实现文件上传/","link":"","permalink":"http://569258yin.github.io/2017/03/13/javaweb与app实现文件上传/","excerpt":"","content":"前言·最近在做毕设，然后app需要发送图文消息，就需要在app端实现图片上传，在web端实现文件接收，中间遇到点小意外，记在这里。 1.开发所需第三方jar包app端：HttpURLConnection(jdk自带) web端: commons-fileupload maven路径： 12345 &lt;dependency&gt;&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 2.JavaWeb端代码服务器端主要是为了接收客户端的请求，从请求解析出文件，可支持多文件上传，并创建了文件夹和随机名字，以保证生成的文件路径唯一，这里路径有两个，一个是保存的本地真实路径，用于 写文件，第二个是为了生成url，便于客户端访问，并以json的方式进行返回。 Controller代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.ProgressListener;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import com.aygxy.fmaket.bean.ImagePath;import com.aygxy.fmaket.debug.DebugLog;import com.aygxy.fmaket.param.GlobalParams;import com.aygxy.fmaket.util.FileUtil;import com.aygxy.fmaket.util.GsonUtil;@Controller@RequestMapping(&quot;file&quot;)public class FileAction &#123; private final static String ENCODING = &quot;utf-8&quot;; static&#123; &#125; @RequestMapping(&quot;imgUpload.action&quot;) public void imageUpload(HttpServletRequest request,HttpServletResponse response)&#123; //创建工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //设置缓冲区的大小 factory.setSizeThreshold(1024*1024*5); String result = &quot;&quot;; //本地服务器真实路径 String imgPath = request.getSession().getServletContext().getRealPath(File.separator+&quot;extimg&quot;); //上传时生成的临时文件保存目录 String tempPath = request.getSession().getServletContext().getRealPath(File.separator+&quot;temp&quot;); //设置上传文件临时文件的保存路径 File tmpFile = new File(tempPath); if (!tmpFile.exists()) &#123; //创建临时目录 tmpFile.mkdir(); &#125; factory.setRepository(tmpFile); InputStream is = null; OutputStream os = null; try &#123; //创建一个文件上传解析器 ServletFileUpload upload = new ServletFileUpload(factory); upload.setProgressListener(new ProgressListener() &#123; @Override public void update(long pBytesRead, long pContentLength, int arg2) &#123; DebugLog.logger.info(&quot;文件大小为：&quot; + pContentLength + &quot;,当前已处理：&quot; + pBytesRead); &#125; &#125;); //设置编码格式 upload.setHeaderEncoding(ENCODING); //判断是否是表单提交 if(!ServletFileUpload.isMultipartContent(request))&#123; DebugLog.logger.info(&quot;不正确的文件格式&quot;); result = GsonUtil.objectToString(new ImagePath(&quot;-1&quot;, &quot;不正确的文件格式&quot;)); response.getOutputStream().write(result.getBytes(ENCODING)); return; &#125; //设置图片最大限制 upload.setFileSizeMax(1024*1024); //使用解析器对上传的文件进行解析 List&lt;FileItem&gt; list = upload.parseRequest(request); DebugLog.logger.debug(&quot;解析出的文件列表为&quot;+list.toString()); if(list.size() &gt; 0 )&#123; List&lt;String&gt; imageLists = new ArrayList&lt;String&gt;(); for (FileItem fileItem : list) &#123; //如果封装的是普通的数据 if (fileItem.isFormField() &amp;&amp; fileItem.getSize() &gt; 0) &#123; String requestName = fileItem.getFieldName(); //解决普通输入项的中文乱码问题 String requestValue = fileItem.getString(ENCODING); DebugLog.logger.info(&quot;文件上传携带参数==&gt;&quot;+requestName+&quot;:&quot;+requestValue); &#125;else&#123; //封装的是上传的文件 //得到上传的文件名 String fileName = fileItem.getName(); DebugLog.logger.debug(&quot;上传文件的文件名：&quot;+fileName); if (fileName == null || fileName.trim().equals(&quot;&quot;)) &#123; continue; &#125; //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的， //如： c:\\a\\b\\1.txt，而有些只是单纯的文件名，如：1.txt //处理获取到的上传文件的文件名的路径部分，只保留文件名 fileName = fileName.substring(fileName.lastIndexOf(&quot;\\\\&quot;)+1); //得到上传文件的扩展名 String fileExtName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+1); DebugLog.logger.debug(&quot;上传的文件的扩展名是：&quot;+fileExtName); boolean allowCount = false; for(int i = 0;i&lt;GlobalParams.IMAGE_ALLOW_END.length;i++)&#123; if(GlobalParams.IMAGE_ALLOW_END[i].equals(fileExtName))&#123; allowCount = true; break; &#125; &#125; if(!allowCount)&#123; DebugLog.logger.info(&quot;文件后缀不正确&quot;); result = GsonUtil.objectToString(new ImagePath(&quot;-2&quot;, &quot;文件格式不正确&quot;)); response.getOutputStream().write(result.getBytes(ENCODING)); return; &#125; //获取item上传的输入流 //获取唯一名，随机生成 String saveFileName= FileUtil.makeFileName(fileExtName); //根据文件名记性hash生成文件夹 String filePath = FileUtil.makePath(saveFileName, &quot;&quot;); String realFilePath = imgPath + filePath; //用于url生成 String otherFilePath = request.getContextPath() + File.separator + &quot;extimg&quot; + filePath; //创建文件夹 File filePathFile = new File(realFilePath); if (!filePathFile.exists()) &#123; filePathFile.mkdirs(); &#125; //创建文件 File file = new File(filePathFile,saveFileName); if (!file.exists()) &#123; file.createNewFile(); &#125; DebugLog.logger.debug(&quot;本地创建的文件路径：&quot;+file.getAbsolutePath()); is = fileItem.getInputStream(); os = new FileOutputStream(file); //创建一个缓冲区 byte[] buff = new byte[2048]; int len = 0; while((len = is.read(buff)) != -1)&#123; os.write(buff, 0, len); &#125; //删除处理文件的临时文件 fileItem.delete(); otherFilePath = GlobalParams.SERVER_URL + otherFilePath + File.separator + saveFileName; otherFilePath = otherFilePath.replace(&apos;\\\\&apos;, &apos;/&apos;); DebugLog.logger.debug(&quot;生成的图片url为:&quot;+otherFilePath); imageLists.add(otherFilePath); &#125; &#125; result = GsonUtil.objectToString(new ImagePath(imageLists)); response.getOutputStream().write(result.getBytes(ENCODING)); &#125; &#125; catch (FileUploadException e) &#123; DebugLog.logger.error(&quot;文件上传失败&quot;, e); &#125; catch (UnsupportedEncodingException e) &#123; DebugLog.logger.error(&quot;不支持的编码格式&quot;, e); &#125; catch (IOException e) &#123; DebugLog.logger.error(&quot;文件读写失败&quot;, e); &#125; catch (Exception e) &#123; DebugLog.logger.error(&quot;文件上传未知异常&quot;, e); &#125;finally&#123; //关闭流 if(is != null)&#123; try &#123; is.close(); &#125; catch (Exception e) &#123; &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125;&#125; FileUtil 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class FileUtil &#123; /** * 根据文件后缀生成一个随机的文件名 * @param fileExtName * @return */ public static String makeFileName(String fileExtName)&#123; //为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名 return UUID.randomUUID().toString() + &quot;.&quot; + fileExtName; &#125; /** * 为防止一个目录下面出现太多文件，要使用hash算法打散存储 * * @param filename 文件名，要根据文件名生成存储目录 * @param savePath 文件存储路径 * @return 新的存储目录 */ public static String makePath(String filename,String savePath)&#123; //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址 int hashcode = filename.hashCode(); int dir1 = hashcode&amp;0xf; //0--15 int dir2 = (hashcode&amp;0xf0)&gt;&gt;4; //0-15 int dir3 = (int) (100000 + Math.random()*999999); //构造新的保存目录 String dir = savePath + File.separator + dir1 + File.separator + dir2 + File.separator + dir3; //upload\\2\\3 upload\\3\\5// //File既可以代表文件也可以代表目录// File file = new File(dir);// //如果目录不存在// if(!file.exists())&#123;// //创建目录// file.mkdirs();// &#125; return dir; &#125; /** * 得到要删除图片的真实路径 * @param request * @param tempPath * @return */ public static String getLocalImageUrl(String tempPath)&#123; String url = &quot;&quot;; String[] strs = tempPath.split(&quot;/&quot;); for (int i = 0; i &lt; strs.length; i++) &#123; System.out.println(strs[i]); &#125;// url = GlobalParams.path+File.separator+strs[5]+File.separator+strs[6]; System.out.println(url); return url; &#125; public static void main(String[] args) &#123; System.out.println(makePath(&quot;1.jpg&quot;, &quot;Path&quot;)); &#125;&#125; app端app 端利用httpConnection，并设置请求方式为post，将context-type改为multipart/form-data,一定要注意分割符的位置，我是因为这导致两种上传不成功，一是服务器端明明能接收 到文件，但是就是从request解析的时候为空，二是批量上传的时候发现只能上传成功一张，服务器并没有解析出多个文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 上传图片 * @param files * @return */public static String uploadImage(List&lt;File&gt; files) &#123; URL url; DataOutputStream ds = null; BufferedReader bufferedReader = null; //为了分割 String end = &quot;\\r\\n&quot;; String Hyphens = &quot;--&quot;; String boundary = &quot;WUm4580jbtwfJhNp7zi1djFEO3wNNm&quot;; try &#123; if (files != null &amp;&amp; files.size() &gt; 0) &#123; url = new URL(ConstantValue.URL_ROOT + ConstantValue.IMAGE_UPLOAD); // 打开链接 URLConnection connection = url.openConnection(); HttpURLConnection httpURLConnection = (HttpURLConnection) connection; httpURLConnection.setRequestMethod(&quot;POST&quot;); httpURLConnection.setReadTimeout(30000); httpURLConnection.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;); httpURLConnection.setRequestProperty(&quot;Content-type&quot;, &quot;multipart/form-data;boundary=&quot; + boundary); httpURLConnection.setRequestProperty(&quot;charset&quot;, &quot;utf-8&quot;); httpURLConnection.setUseCaches(false); httpURLConnection.setDoInput(true); httpURLConnection.setDoOutput(true); ds = new DataOutputStream(httpURLConnection.getOutputStream()); for (int i = 0;i&lt;files.size();i++) &#123; File file = files.get(i); //注意加上分隔符此时只有一个Hyphens ds.writeBytes(Hyphens + boundary + end); //这里的格式不能改变，我将name换了别的名字结果服务器端不能正常接收文件 ds.writeBytes(&quot;Content-Disposition: form-data; &quot; + &quot;name=\\&quot;file&quot;+i+&quot;\\&quot;;filename=\\&quot;&quot; + file.getName() + &quot;\\&quot;&quot; + end); ds.writeBytes(end); FileInputStream fStream = new FileInputStream(file); byte[] buff = new byte[1024]; int length = -1; while((length = fStream.read(buff)) != -1)&#123; ds.write(buff,0,length); &#125; ds.writeBytes(end); fStream.close(); &#125; //结尾分隔符，注意此处为Hyphens + boundary + Hyphens+ end,有两个Hyphens，我刚开始没注意，结果就是不能批量上传文件 ds.writeBytes(Hyphens + boundary + Hyphens+ end); ds.flush(); bufferedReader = new BufferedReader( new InputStreamReader(httpURLConnection.getInputStream(),&quot;UTF-8&quot;)); String jsonString2 = bufferedReader.readLine(); Logger.d(jsonString2); return jsonString2; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(ds != null)&#123; try &#123; ds.close(); &#125; catch (Exception e) &#123; &#125; &#125; if(bufferedReader != null)&#123; try &#123; bufferedReader.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; return null;&#125; 结尾有时候觉得自己还是不够认真，在网上搜了这方面的经验和代码，结果自己实现的时候会因为一些稍微不一样的地方导致各种不成功，就很无奈，后来就慢慢排查，细心一点就可以找到问题的关键了，暂时只写了一种客户端的实现上传的办法，还有一种是利用httpClient进行上传文件，代码稍有不同，之后再补上。关于分隔符的问题还没搞懂，没有去研究其实现原理，可能也存在误解，但这份代码时测试的没有问题的。","categories":[{"name":"Java","slug":"Java","permalink":"http://569258yin.github.io/categories/Java/"}],"tags":[{"name":"--Java --app","slug":"Java-app","permalink":"http://569258yin.github.io/tags/Java-app/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-13T02:14:30.996Z","updated":"2017-03-13T02:14:30.996Z","comments":true,"path":"2017/03/13/hello-world/","link":"","permalink":"http://569258yin.github.io/2017/03/13/hello-world/","excerpt":"","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hexo搭建博客小白教程","slug":"Hexo搭建博客小白教程","date":"2016-11-21T23:44:12.000Z","updated":"2017-03-13T02:20:20.647Z","comments":true,"path":"2016/11/22/Hexo搭建博客小白教程/","link":"","permalink":"http://569258yin.github.io/2016/11/22/Hexo搭建博客小白教程/","excerpt":"","content":"前言·利用hexo在Github上搭建个人博客是我从我对象那里知道的，她学的前端，我学的Java，一直没了解过这个东西，前几天发现了，果断喜欢上了，以前都是在CSDN上写博客。然后，我就开始了研究，到了现在，终于好了，网上教程确实很多啊，但是其间也有一些问题，然后昨天，我女朋友问了几个问题(女友还是小白啊，毕竟妹子)，在添加主题的地方。比如：1234git clone http:.......git themes/icualscd themes/icualsgit pull 这样我们觉得很简单的，对于刚学的妹子来说确实是一个挑战啊！！对于Lunix命令基本不懂得啊.So，我就写了这篇博客给我女友看，是不是很有爱的啊。 参考先放我看过的教程，都可以提供参考的。使用hexo，如果换了电脑怎么更新博客？hexo+github快速搭建个人博客 Github项目创建 1.注册Github账号Github官网 点击上图的 sign up 然后就进入下图填写个人注册信息的界面，上面还有总步骤说明 然后把三个步骤走完就OK啦！这时候你就拥有了你的Github账号和远程仓库。 2.创建项目在你登录过的Github界面，右上方找到一个 + 号，然后点击，再选择new repository,就是新建项目啦。 然后就是新建项目界面，输入你要新建的项目名称，这里我们要建一个博客，所有名字要为你的Github账号加上.github.io比如我的Github账号为569258yin，那我创建的项目名称就为569258yin.github.io,下图可以看到我的项目名称已经存在了。 然后描述内容可以不写，或者写…（对了，免费版的Github账号都是public的，也就是你的项目被人都可以看到，但是别人是没有权利修改的） 3.创建分支 创建分支为了我们能够在不同的电脑上方便修改博客，首先，Github上master主分支存放 的是hexo将我们的源文件转化生成的静态网页，是不存储我们实际操作的源文件的，我刚开 始也不知道，然后去了公司，从Github上克隆了我的项目，准备做修改呢，结果全是静态网 页，并不能直接修改，所有参考了知乎上大神给的方法。 项目分为两个分支：master主分支用了存放静态网页，hexo(名字随意)分支用了存放项目源文件 当刚创好分支，如果你还没添加任何描述，项目界面是这样的如果你的也是，就点图中红色标注的README，然后就可以添加一些描述啦。这里可以简单写一句话，关于如何使用README，可另行百度。如果你的界面是下面的这种，那就可以直接点Branch:master,(branch的意思就是分支,master代表主分支)，在文本框中输入hexo（分支名）然后点击create branch:hexo就可以了。 4.设置hexo分支为默认分支点击项目设置,进到如下界面 然后再选择Branch设置，可以看到当前默认分支为master，点击选择我们创建的hexo，然后点击右边update就可以了 本地搭建Hexo博客 1.在本地创建一个文件夹，比如我的取名为hexo，然后鼠标右键git branch，调出git控制台工具。如果你还没有装过这个软件，那就需要先安装软件下载地址,不会安装的同学可以参考廖雪峰的Git安装教程及使用说明打开控制台后输入 git clone https://github.com/569258yin/test.github.io.git 克隆你在Github创建的项目到本地，后面的网址是我的，你的项目网址在Github网站项目可以查看到，如下图：克隆完成后就会在hexo生成对应的项目文件夹 2.安装Node.js 下载地址：Node官网，下载任意版本，安装就可以了，这个很简单。安装完成可以在git bash控制台输入 node -v 如果能显示版本号就说明安装成功！ 3.安装hexo插件 在git bash中利用node 自带的包管理器进行安装： 1输入 npm install -g hexo(或者npm i -g hexo) 4.初始化hexo 首先需要将git bash 当前文件路径选到你的项目根目录下，不会命令的可以直接将当前的git bash关掉，然后直接鼠标点进去项目文件夹，鼠标右键选择 git bash 就可以了然后执行 1hexo init 这一步，我只能说超级慢的啊，视网络情况，反正我是等了很久……. 5.测试是否安装完毕 1输入 hexo generate(或 hexo g) 初始化本地文件，这时候hexo会把我们的源文件转化为静态网页， 然后 1输入 hexo server(或 hexo s) 意思是在本地创建一个服务器用了展示我们生成的网页，这一步是非常方便的，以后我们有任何修改只需在本地查看，确保正确后再发布到github上。 之后打开你电脑上的浏览器，输入http:\\localhost:4000访问，能显示就说明大功告成啦，安装完毕！！！ 将本地项目源文件上传到Github上","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://569258yin.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://569258yin.github.io/tags/hexo/"}]}]}